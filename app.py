import streamlit as st
import json
import base64
import urllib.parse
from utils import load_game, save_game
from archivist import get_archivist_response, update_world_state
from narrator import narrate_scene
from illustrator import get_image_prompt
from gtts import gTTS
from io import BytesIO
from director import update_story_state 
from dreamer import dream_up_content
from creator import create_new_entity
from scribe import scan_story_for_entities

# --- UI CONFIGURATION ---
st.set_page_config(page_title="The Dungeon Master", layout="wide")

st.title("‚öîÔ∏è The Dungeon Master")
st.markdown("*A Multi-Agent AI Roleplaying Engine*")

# --- SIDEBAR: WORLD STATE ---
st.sidebar.header("üõ°Ô∏è Character Sheet")

current_state = load_game()

if current_state:
    player = current_state['player']
    
    # Stats
    st.sidebar.subheader(player['name'])
    current_hp = player['hp']
    max_hp = player['max_hp']
    bar_value = max(min(current_hp / max_hp, 1.0), 0.0)
    st.sidebar.progress(bar_value)
    st.sidebar.write(f"**HP:** {current_hp} / {max_hp}")
    
    # Inventory
    st.sidebar.subheader("üéí Inventory")
    for item in player['inventory']:
        st.sidebar.code(item)
    
    # --- DYNAMIC QUEST LOG ---
    st.sidebar.subheader("üìú Current Story")
    if "story_state" in current_state:
        story_data = current_state["story_state"]
        st.sidebar.info(f"**Goal:** {story_data.get('current_objective', 'Explore')}")
        st.sidebar.write(f"**Genre:** {story_data.get('genre', 'Adaptive')}")
        with st.sidebar.expander("Director's Notes"):
            st.write(f"*{story_data.get('narrative_direction')}*")
    # -------------------------

    # Map
    st.sidebar.subheader("üó∫Ô∏è World Map")
    if "locations" in current_state:
        try:
            import graphviz
            graph = graphviz.Digraph()
            graph.attr(rankdir='LR', size='10', bgcolor='transparent')
            
            for loc_id, loc_data in current_state["locations"].items():
                if loc_id == current_state.get("current_location_id"):
                    graph.node(loc_id, label=loc_data["name"], style='filled', fillcolor='#ffcccc', shape='box')
                else:
                    graph.node(loc_id, label=loc_data["name"], shape='ellipse', style='filled', fillcolor='#f0f2f6')
            
            st.sidebar.graphviz_chart(graph)
        except ImportError:
            st.sidebar.warning("Install 'graphviz' to see the map.")

    # Debug Flags
    with st.sidebar.expander("üåç World Flags"):
        st.sidebar.json(current_state['world_flags'])
    with st.sidebar.expander("üë• NPC Status"):
        st.sidebar.json(current_state['npcs'])
    with st.sidebar.expander("‚òÅÔ∏è Shadow Queue (Dreamer)"):
        st.json(current_state.get("shadow_queue", []))

# --- CHAT LOGIC ---

if "messages" not in st.session_state:
    st.session_state.messages = []
    st.session_state.messages.append({
        "role": "assistant", 
        "content": "The world is unformed. How do you begin?"
    })

# --- HISTORY LOOP ---
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        if "debug_log" in message:
            with st.expander("ü§ñ Archivist Logic (Debug)"):
                st.json(message["debug_log"])
        
        if "art_url" in message and message["art_url"]:
             with st.expander("üé® Illustrator's Vision"):
                st.image(message["art_url"], caption="Generated by AI (Flux Model)")
        
        st.markdown(message["content"])

        if "audio_b64" in message and message["audio_b64"]:
            audio_html = f"""
                <audio controls style="width: 100%;">
                <source src="data:audio/mp3;base64,{message['audio_b64']}" type="audio/mp3">
                </audio>
            """
            st.markdown(audio_html, unsafe_allow_html=True)

# --- USER INPUT ---
if prompt := st.chat_input("What is your command?"):
    st.chat_message("user").markdown(prompt)
    st.session_state.messages.append({"role": "user", "content": prompt})

    # --- 1. ARCHIVIST & PROACTIVE WORLD SEEDER ---
    with st.spinner("The Archivist is thinking..."):
        updates = get_archivist_response(current_state, prompt)
        
        # PROACTIVE LOGIC
        if "error" in updates and updates["error"] == "target_missing":
            missing_name = updates.get("target_name", "Unknown Area")
            
            # Detect Vague Movement
            if missing_name.lower() in ["outside", "exit", "door", "leave", "out"]:
                missing_name = "The Surrounding Area" 
            
            with st.spinner(f"‚ö†Ô∏è Discovering '{missing_name}'..."):
                curr_loc = current_state.get("current_location_id", "unknown")
                
                # Pass current_state so Creator can check the Dreamer's Shadow Queue
                new_entity = create_new_entity(missing_name, curr_loc, current_state)
                
                if new_entity:
                    if new_entity["type"] == "location":
                        loc_id = new_entity["id"]
                        loc_data = new_entity["data"]
                        
                        # --- FIX: Prevent Self-Looping Exits ---
                        clean_exits = [e for e in loc_data.get("exits", []) 
                                      if e.lower() != loc_data["name"].lower() 
                                      and "back to" not in e.lower()]
                        loc_data["exits"] = clean_exits
                        
                        if "locations" not in current_state: current_state["locations"] = {}
                        current_state["locations"][loc_id] = loc_data
                        
                        # Link Exits (Old -> New)
                        old_loc_id = current_state["current_location_id"]
                        old_loc_name = current_state["locations"].get(old_loc_id, {}).get("name", "Previous Area")
                        loc_data["exits"].append(f"Back to {old_loc_name}")

                        if old_loc_id in current_state["locations"]:
                            if "exits" not in current_state["locations"][old_loc_id]:
                                current_state["locations"][old_loc_id]["exits"] = []
                            # Only add if not already there
                            if loc_data["name"] not in current_state["locations"][old_loc_id]["exits"]:
                                current_state["locations"][old_loc_id]["exits"].append(loc_data["name"])

                        current_state["current_location_id"] = loc_id
                        
                        # --- VISUAL SUGGESTIONS ---
                        if "suggested_exits" in loc_data:
                            # The Creator returns visual descriptions now, not just names
                            suggestions = "; ".join(loc_data["suggested_exits"])
                            updates["narrative_cue"] = f"You arrive at {loc_data['name']}. {loc_data['description']} Visible paths: {suggestions}."

                        st.toast(f"‚ú® Discovered: {loc_data['name']}")
                    
                    elif new_entity["type"] == "npc":
                         npc_id = new_entity["id"]
                         current_state["npcs"][npc_id] = new_entity["data"]
                         st.toast(f"‚ú® Met NPC: {new_entity['data']['name']}")

                    elif new_entity["type"] == "item":
                         current_state["player"]["inventory"].append(new_entity["item_name"])
                         # Narrative cue for item
                         updates["narrative_cue"] = f"You found a {new_entity['item_name']}."
                         st.toast(f"‚ú® Found Item: {new_entity['item_name']}")

                    save_game(current_state)
                    
                    if "narrative_cue" not in updates:
                        updates = get_archivist_response(current_state, prompt)
        
        log_msg = updates.get("narrative_cue", "Events unfold...")
        new_state = update_world_state(updates)

    # --- 2. THE DIRECTOR (ADAPTIVE STORY ENGINE) ---
    with st.spinner("The Director is adapting the plot..."):
        new_story_state = update_story_state(new_state, prompt, log_msg)
        new_state["story_state"] = new_story_state
        save_game(new_state)

    # --- NARRATOR ---
    with st.spinner("The Narrator is writing..."):
        story = narrate_scene(new_state, prompt, log_msg)

    # --- THE SCRIBE (Sync Story to State) ---
    # This runs silently to catch things like "You wake up with a cutlass."
    if story:
        new_entities = scan_story_for_entities(story, new_state)
        
        # 1. Add Items
        if "new_items" in new_entities and new_entities["new_items"]:
            for item in new_entities["new_items"]:
                new_state["player"]["inventory"].append(item)
                st.toast(f"üìù Scribe added item: {item}")
        
        # 2. Add NPCs
        if "new_npcs" in new_entities and new_entities["new_npcs"]:
            for npc in new_entities["new_npcs"]:
                # Generate a unique ID
                nid = f"scribe_npc_{npc['name'].lower().replace(' ', '_')}"
                if nid not in new_state["npcs"]:
                    new_state["npcs"][nid] = {
                        "name": npc['name'],
                        "location_id": new_state["current_location_id"], # Assume they are here
                        "status": npc.get("status", "alive"),
                        "attitude": "unknown",
                        "description": npc.get("description", "Noted by the Scribe.")
                    }
                    st.toast(f"üìù Scribe recorded NPC: {npc['name']}")

        # 3. Add Locations (as neighbors)
        if "new_locations" in new_entities and new_entities["new_locations"]:
            current_loc = new_state["locations"].get(new_state["current_location_id"])
            if current_loc:
                for loc in new_entities["new_locations"]:
                    # We don't teleport there, we just add it as a visible exit/node
                    lid = f"scribe_loc_{loc['name'].lower().replace(' ', '_')}"
                    if lid not in new_state["locations"]:
                        new_state["locations"][lid] = {
                            "name": loc['name'],
                            "description": loc.get("description", "Spotted in the distance."),
                            "exits": [f"Back to {current_loc['name']}"]
                        }
                        # Link it
                        if "exits" not in current_loc: current_loc["exits"] = []
                        current_loc["exits"].append(loc['name'])
                        st.toast(f"üìù Scribe mapped: {loc['name']}")

        # Save the Scribe's work
        save_game(new_state)

    # --- 4. ILLUSTRATOR ---
    image_url = None
    with st.spinner("The Illustrator is sketching..."):
        art_prompt = get_image_prompt(story)
        if art_prompt:
             encoded_prompt = urllib.parse.quote(art_prompt)
             image_url = f"https://image.pollinations.ai/prompt/{encoded_prompt}?width=1024&height=512&model=flux&seed=42&nologo=true"

    # --- 5. AUDIO GENERATION ---
    audio_b64 = None
    if story:
        try:
            # Using Edge-TTS or gTTS (swappable). Using gTTS as fallback for simple setup.
            tts = gTTS(text=story, lang='en', slow=False)
            audio_bytes = BytesIO()
            tts.write_to_fp(audio_bytes)
            audio_bytes.seek(0)
            audio_b64 = base64.b64encode(audio_bytes.read()).decode()
        except Exception as e:
            print(f"Audio Generation Error: {e}")

    # --- SAVE TO HISTORY ---
    st.session_state.messages.append({
        "role": "assistant", 
        "content": story,
        "art_url": image_url,
        "audio_b64": audio_b64, 
        "debug_log": updates
    })
    
    # --- 6. THE DREAMER (Background Generation) ---
    with st.spinner("The Dreamer is imagining the future..."):
        new_dreams = dream_up_content(new_state)
        if new_dreams:
            if "shadow_queue" not in new_state:
                new_state["shadow_queue"] = []
            new_state["shadow_queue"].extend(new_dreams)
            save_game(new_state)
            
    # --- RERUN ---
    st.rerun()