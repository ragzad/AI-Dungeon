import streamlit as st
import json
import base64
import urllib.parse
from utils import load_game, save_game
from archivist import get_archivist_response, update_world_state
from narrator import narrate_scene
from illustrator import get_image_prompt
from gtts import gTTS
from io import BytesIO

# --- UI CONFIGURATION ---
st.set_page_config(page_title="The Dungeon Master", layout="wide")

st.title("‚öîÔ∏è The Dungeon Master")
st.markdown("*A Multi-Agent AI Roleplaying Engine*")

# --- SIDEBAR: WORLD STATE ---
st.sidebar.header("üõ°Ô∏è Character Sheet")

current_state = load_game()

if current_state:
    player = current_state['player']
    
    # Stats
    st.sidebar.subheader(player['name'])
    current_hp = player['hp']
    max_hp = player['max_hp']
    bar_value = max(min(current_hp / max_hp, 1.0), 0.0)
    st.sidebar.progress(bar_value)
    st.sidebar.write(f"**HP:** {current_hp} / {max_hp}")
    
    # Inventory
    st.sidebar.subheader("üéí Inventory")
    for item in player['inventory']:
        st.sidebar.code(item)
    
    # Map
    st.sidebar.subheader("üó∫Ô∏è World Map")
    if "locations" in current_state:
        try:
            import graphviz
            graph = graphviz.Digraph()
            graph.attr(rankdir='LR', size='10', bgcolor='transparent')
            
            for loc_id, loc_data in current_state["locations"].items():
                if loc_id == current_state.get("current_location_id"):
                    graph.node(loc_id, label=loc_data["name"], style='filled', fillcolor='#ffcccc', shape='box')
                else:
                    graph.node(loc_id, label=loc_data["name"], shape='ellipse', style='filled', fillcolor='#f0f2f6')
            
            st.sidebar.graphviz_chart(graph)
        except ImportError:
            st.sidebar.warning("Install 'graphviz' to see the map.")

    # Debug Flags
    with st.sidebar.expander("üåç World Flags"):
        st.sidebar.json(current_state['world_flags'])
    with st.sidebar.expander("üë• NPC Status"):
        st.sidebar.json(current_state['npcs'])

# --- CHAT LOGIC ---

if "messages" not in st.session_state:
    st.session_state.messages = []
    st.session_state.messages.append({
        "role": "assistant", 
        "content": "You stand in the dim light of The Rusty Tankard. The air smells of stale ale. What do you do?"
    })

# --- HISTORY LOOP (FIXED TO SHOW AUDIO) ---
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        # 1. Debug Logs
        if "debug_log" in message:
            with st.expander("ü§ñ Archivist Logic (Debug)"):
                st.json(message["debug_log"])
        
        # 2. Visuals
        if "art_url" in message and message["art_url"]:
             with st.expander("üé® Illustrator's Vision"):
                st.image(message["art_url"], caption="Generated by AI (Flux Model)")
        
        # 3. Story Content
        st.markdown(message["content"])

        # 4. AUDIO (THE FIX IS HERE)
        # We now check history for audio data and render it
        if "audio_b64" in message and message["audio_b64"]:
            audio_html = f"""
                <audio controls style="width: 100%;">
                <source src="data:audio/mp3;base64,{message['audio_b64']}" type="audio/mp3">
                </audio>
            """
            st.markdown(audio_html, unsafe_allow_html=True)

# --- USER INPUT ---
if prompt := st.chat_input("What is your command?"):
    st.chat_message("user").markdown(prompt)
    st.session_state.messages.append({"role": "user", "content": prompt})

    # --- ARCHIVIST & PROACTIVE WORLD SEEDER ---
    with st.spinner("The Archivist is thinking..."):
        updates = get_archivist_response(current_state, prompt)
        
        # PROACTIVE LOGIC
        if "error" in updates and updates["error"] == "target_missing":
            missing_name = updates.get("target_name", "Unknown Area")
            
            # Detect Vague Movement
            if missing_name.lower() in ["outside", "exit", "door", "leave", "out"]:
                missing_name = "The Surrounding Area" 
            
            with st.spinner(f"‚ö†Ô∏è Discovering '{missing_name}'..."):
                from creator import create_new_entity
                curr_loc = current_state.get("current_location_id", "unknown")
                
                new_entity = create_new_entity(missing_name, curr_loc)
                
                if new_entity:
                    if new_entity["type"] == "location":
                        loc_id = new_entity["id"]
                        loc_data = new_entity["data"]
                        
                        if "locations" not in current_state: current_state["locations"] = {}
                        current_state["locations"][loc_id] = loc_data
                        
                        # Link Exits
                        old_loc_id = current_state["current_location_id"]
                        if old_loc_id in current_state["locations"]:
                            if "exits" not in current_state["locations"][old_loc_id]:
                                current_state["locations"][old_loc_id]["exits"] = []
                            current_state["locations"][old_loc_id]["exits"].append(loc_data["name"])

                        current_state["current_location_id"] = loc_id
                        
                        if "suggested_exits" in loc_data:
                            suggestions = ", ".join(loc_data["suggested_exits"])
                            updates["narrative_cue"] = f"You arrive at {loc_data['name']}. {loc_data['description']} You see paths leading to: {suggestions}."

                        st.toast(f"‚ú® Discovered: {loc_data['name']}")
                    
                    elif new_entity["type"] == "npc":
                         npc_id = new_entity["id"]
                         current_state["npcs"][npc_id] = new_entity["data"]
                         st.toast(f"‚ú® Met NPC: {new_entity['data']['name']}")

                    elif new_entity["type"] == "item":
                         current_state["player"]["inventory"].append(new_entity["item_name"])
                         st.toast(f"‚ú® Found Item: {new_entity['item_name']}")

                    save_game(current_state)
                    
                    if "narrative_cue" not in updates:
                        updates = get_archivist_response(current_state, prompt)
        
        log_msg = updates.get("narrative_cue", "Events unfold...")
        new_state = update_world_state(updates)

    # --- NARRATOR ---
    with st.spinner("The Narrator is writing..."):
        story = narrate_scene(new_state, prompt, log_msg)

    # --- ILLUSTRATOR ---
    image_url = None
    with st.spinner("The Illustrator is sketching..."):
        art_prompt = get_image_prompt(story)
        if art_prompt:
             encoded_prompt = urllib.parse.quote(art_prompt)
             image_url = f"https://image.pollinations.ai/prompt/{encoded_prompt}?width=1024&height=512&model=flux&seed=42&nologo=true"

    # --- AUDIO GENERATION (SAVE TO B64) ---
    audio_b64 = None
    if story:
        try:
            tts = gTTS(text=story, lang='en', slow=False)
            audio_bytes = BytesIO()
            tts.write_to_fp(audio_bytes)
            audio_bytes.seek(0)
            audio_b64 = base64.b64encode(audio_bytes.read()).decode()
        except Exception as e:
            print(f"Audio Generation Error: {e}")

    # --- SAVE TO HISTORY ---
    # We save BEFORE we rerun, so the History Loop picks it up
    st.session_state.messages.append({
        "role": "assistant", 
        "content": story,
        "art_url": image_url,
        "audio_b64": audio_b64, # <--- Saving the Audio Data Here
        "debug_log": updates
    })
    
    # --- RERUN ---
    st.rerun()